package info.zznet.znms.spider;

import info.zznet.znms.base.common.ZNMSLogger;
import info.zznet.znms.base.dao.ThresholdValueMapper;
import info.zznet.znms.base.dao.ThresholdValueTriggerLogMapper;
import info.zznet.znms.base.entity.Host;
import info.zznet.znms.base.entity.ThresholdValue;
import info.zznet.znms.base.entity.ThresholdValueTriggerLog;
import info.zznet.znms.base.util.MailUtil;
import info.zznet.znms.base.util.StringUtil;
import info.zznet.znms.base.util.UUIDGenerator;
import info.zznet.znms.spider.bean.ScanHost;
import info.zznet.znms.spider.bean.ScanResult;
import info.zznet.znms.spider.constants.SnmpConstants;
import info.zznet.znms.spider.util.SnmpUtil;
import info.zznet.znms.web.WebRuntimeData;
import info.zznet.znms.web.module.system.bean.SystemOptionBean;
import info.zznet.znms.web.module.system.service.HostService;
import info.zznet.znms.web.start.SystemStartThread;

import java.math.BigDecimal;
import java.net.InetAddress;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

import javax.annotation.Resource;

import org.apache.commons.lang.StringUtils;
import org.apache.http.conn.util.InetAddressUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.MailException;
import org.springframework.mail.MailSender;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.stereotype.Service;

/**
 * Created by shenqilei on 2016/9/21.
 */
@Service
public class Engine {
	
	@Autowired
	private ThresholdValueMapper thresholdValueMapper;
	
	@Autowired
	private ThresholdValueTriggerLogMapper logMapper;
	
	@Autowired
	private HostService hostService;
	
	private WebRuntimeData webRuntimeData = WebRuntimeData.instance;
	
	SystemOptionBean systemOptionBean;
	
    public static final Map<String,ScanHost> hosts = new ConcurrentHashMap<>(1000);

    //TODO 根据CPU个数设置线程数量
    private static final ExecutorService scanExecutor = Executors.newFixedThreadPool(4);

    private static final ExecutorService checkExecutor = Executors.newFixedThreadPool(4);
    
    private static final ExecutorService thresholdValueExecutor = Executors.newFixedThreadPool(4);

    public static final LinkedBlockingQueue<ScanResult> queue = new LinkedBlockingQueue<>(SnmpConstants.ENGINE_QUEUE_CAPACITY);
    
    public static final LinkedBlockingQueue<ScanResult> otherQueue = new LinkedBlockingQueue<>(SnmpConstants.ENGINE_QUEUE_CAPACITY);


    public void scan(){
        Iterator<Map.Entry<String,ScanHost>> it = hosts.entrySet().iterator();
        while (it.hasNext()){
            final Map.Entry<String,ScanHost> entry = it.next();
            Runnable scanTask = new Runnable() {
                @Override
                public void run() {
                    List<ScanResult> results = SnmpUtil.getResult(entry.getValue());
                    for (ScanResult scanResult:results){
                        try {
                            queue.put(scanResult);
                            int queueSize = queue.size();
                            if (queueSize>SnmpConstants.ENGINE_QUEUE_CAPACITY/2){
                                ZNMSLogger.info("入队，大小已超过最大值一半："+queueSize);
                            }
                            otherQueue.put(scanResult);
                            int otherQueueSize = otherQueue.size();
                            if (otherQueueSize>SnmpConstants.ENGINE_QUEUE_CAPACITY/2){
                                ZNMSLogger.info("入队，大小已超过最大值一半："+otherQueueSize);
                            }
                        } catch (InterruptedException e) {
                            ZNMSLogger.error(e);
                        }
                    }
                }
            };
            scanExecutor.submit(scanTask);
        }
    }

    public void check(){

        Iterator<Map.Entry<String,ScanHost>> it = hosts.entrySet().iterator();
        while (it.hasNext()){
            final Map.Entry<String,ScanHost> entry = it.next();
            Runnable checkTask = new Runnable() {
                @Override
                public void run() {
                    ScanHost scanHost = entry.getValue();
                    String ip = scanHost.getIp();
                    boolean isReachable = false;
                    try{
                        if(InetAddressUtils.isIPv4Address(ip)){
                            //目前只支持ipv4
                            isReachable = InetAddress.getByName(ip).isReachable(1000);
                        }else{
                            isReachable = false;
                            ZNMSLogger.warn("主机["+scanHost.getName()+"]，IP["+scanHost.getIp()+"]非法。");
                        }
                    }catch (Exception e){
                        ZNMSLogger.error(e.getMessage());
                        isReachable = false;
                    }

                    if (isReachable!=scanHost.isReachable()){
                        //可达状态有变
                        scanHost.setReachable(isReachable);
                        hostService.updateHostWorkStatusByIP(ip, isReachable);
                    }

                    WebRuntimeData.instance.pushPingResult(ip, isReachable);
                    if (!isReachable){
                        ZNMSLogger.debug("主机["+scanHost.getName()+"]，IP["+scanHost.getIp()+"]可达状态["+isReachable+"]");
                    }
                }
            };
            checkExecutor.submit(checkTask);
        }


    }

    public void checkQueueSize(){
        ZNMSLogger.info("队列大小："+queue.size());
    }
    
    /**
     * 检查是否触发相关阀值，触发的话，新起一线程来进行后续动作，包括：发送邮件，并记录触发情况等
     * @param scanResult
     */
    public void checkThresholdValueAndOperation(ScanResult scanResult, Map<String, List<ThresholdValue>> map){
    	try {
			List<ThresholdValue> valueList = map.get(scanResult.getRrdDataId());
			if(null!=valueList && valueList.size()>0){
				for(ThresholdValue thresholdValue : valueList){
					if(thresholdValue.getFlowDirection().intValue()==0 || thresholdValue.getFlowDirection().intValue()==2){
						//cpu、内存等超出阀值范围或者流量流出即上行
						BigDecimal currentThresholodValue = new BigDecimal(scanResult.getValue()[0]);
						if(currentThresholodValue.compareTo(valueList.get(0).getWarningHighThresholdValue())==1 
								|| currentThresholodValue.compareTo(valueList.get(0).getWarningLowThresholdValue())==-1){
							triggerOperation(valueList.get(0), currentThresholodValue);
						}
					}else{
						//流量流入即下行
						BigDecimal currentThresholodValue = new BigDecimal(scanResult.getValue()[1]);
						if(currentThresholodValue.compareTo(valueList.get(0).getWarningHighThresholdValue())==1 
								|| currentThresholodValue.compareTo(valueList.get(0).getWarningLowThresholdValue())==-1){
							triggerOperation(valueList.get(0), currentThresholodValue);
						}
					}
				}
			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
    
    /**
     * 触发阀值，发送邮件、记录日志
     */
    public void triggerOperation(ThresholdValue thresholdValue, BigDecimal currentThresholodValue){
    	final ThresholdValue tv = thresholdValue;
    	final BigDecimal ctv = currentThresholodValue;
    	 Runnable thredTask = new Runnable() {
			@Override
			public void run() {
				try {
					//发送邮件
					systemOptionBean = webRuntimeData.instance.getSystemOptionBean();
					if(!StringUtil.isNullString(systemOptionBean.getEmailAddress())){
						String[] emailAddrs = systemOptionBean.getEmailAddress().split(",");
						for(String emailAddr : emailAddrs) {
							try {
								SimpleMailMessage mail = new SimpleMailMessage();
								mail.setTo(StringUtils.trim(emailAddr));
								mail.setSubject("触发阀值");
								String hostName = tv.getHost().getHostName();
								String hostIp = tv.getHost().getHostIp();
								mail.setText(hostName+"("+hostIp+")"+"触发阀值");
								MailUtil.sendmail(mail);
							} catch(Throwable e) {
								ZNMSLogger.error("邮件发送失败:", e);
							}
						}
					}
					//记录触发日志
					ThresholdValueTriggerLog log = new ThresholdValueTriggerLog();
					log.setLogUuid(UUIDGenerator.getGUID());
					log.setCreateTime(new Date());
					log.setCurrentValue(ctv);
					log.setHostUuid(tv.getHostUuid());
					log.setThresholdValueUuid(tv.getThresholdValueUuid());
					StringBuffer sb = new StringBuffer();
					sb.append("告警:阀值["+tv.getThresholdValueName()+"]触发,"+
							"由于当前值为["+ctv+"],");
					if(ctv.compareTo(tv.getWarningHighThresholdValue())==1){
						sb.append("已经高于阀值["+tv.getWarningHighThresholdValue()+"]");
						log.setAlarmValue(tv.getWarningHighThresholdValue());
					}else if(ctv.compareTo(tv.getWarningHighThresholdValue())==-1){
						sb.append("已经低于阀值["+tv.getWarningLowThresholdValue()+"]");
						log.setAlarmValue(tv.getWarningLowThresholdValue());
					}
					log.setDescription(sb.toString());
					logMapper.insert(log);
				} catch (MailException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
    	 };
    	 thresholdValueExecutor.submit(thredTask);
    }
    
}
